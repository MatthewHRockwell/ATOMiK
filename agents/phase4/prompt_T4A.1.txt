You are implementing Phase 4, Task T4A.1 of the ATOMiK project.

FIRST: Read these context files in order:
1. agents/phase4/PHASE4_OVERVIEW.md - Overall Phase 4 strategy and goals
2. agents/phase4/PROMPTS.md - This task's detailed specifications
3. docs/ATOMiK_Development_Roadmap.md - Project context and current status
4. specs/rtl_architecture.md - Hardware architecture reference
5. reports/PHASE_3_COMPLETION_REPORT.md - Hardware validation results

CRITICAL CONTEXT:
- Phase 3 validated hardware: 2.7% LUT, 94.5 MHz, single-cycle operations
- Phase 4 goal: JSON schema → multi-language SDK generation
- Strategy: Simplicity (primitives not products), platform not product
- Key insight: Catalogue position = API namespace

TASK T4A.1: JSON Schema Specification

Create the foundational JSON schema specification that will drive all SDK generation in Phase 4.

## Requirements

### 1. Schema File Structure

Create `specs/atomik_schema_v1.json` with two main sections:

**Section A: Catalogue (Positioning Metadata)**
```json
{
  "catalogue": {
    "vertical": "string (Video|Edge|Network|Finance|Science)",
    "field": "string (domain-specific, e.g., Stream, Security, Sensor)",
    "object": "string (specific component name)",
    "version": "string (semver format)",
    "author": "string",
    "license": "string (e.g., MIT, Apache-2.0)",
    "description": "string"
  }
}
```

**Section B: Schema (Computational Definition)**
```json
{
  "schema": {
    "delta_fields": {
      "field_name": {
        "type": "string (delta_stream|bitmask_delta|parameter_delta)",
        "width": "integer (8, 16, 32, 64, 128, 256)",
        "encoding": "string (spatiotemporal_4x4x4|raw|rle)",
        "compression": "string (xor|rle|none)",
        "default_value": "integer (optional)"
      }
    },
    "operations": {
      "accumulate": {
        "enabled": "boolean",
        "latency_cycles": "integer (default: 1)"
      },
      "reconstruct": {
        "enabled": "boolean",
        "latency_cycles": "integer (default: 1)"
      },
      "rollback": {
        "enabled": "boolean",
        "history_depth": "integer (optional)"
      }
    },
    "constraints": {
      "max_memory_mb": "integer (optional)",
      "max_power_mw": "integer (optional)",
      "update_latency_ms": "integer (optional)",
      "target_frequency_mhz": "integer (optional, default: 94.5)"
    }
  }
}
```

**Section C: Hardware Mapping (Optional)**
```json
{
  "hardware": {
    "target_device": "string (GW1NR-9|..., optional)",
    "rtl_params": {
      "DATA_WIDTH": "integer (must match delta_fields.width)",
      "ENABLE_PARALLEL": "boolean (default: false)",
      "CLOCK_DOMAIN": "string (optional)"
    },
    "synthesis_options": {
      "optimization_goal": "string (area|speed|power, optional)",
      "timing_constraints": "object (optional)"
    }
  }
}
```

### 2. Validation Rules Document

Create `specs/schema_validation_rules.md` specifying:

**Required Fields:**
- catalogue.vertical (must be one of predefined verticals)
- catalogue.object (must be unique within vertical+field)
- catalogue.version (must be valid semver)
- schema.delta_fields (at least one field required)
- schema.operations.accumulate (must be defined)

**Type Constraints:**
- delta_fields.width: must be power of 2, between 8 and 256
- operations.*.latency_cycles: must be positive integer
- constraints.*: must be positive integers if specified

**Cross-Field Dependencies:**
- If hardware.rtl_params.DATA_WIDTH specified, must match delta_fields.*.width
- If operations.rollback.enabled, must specify history_depth

**Namespace Generation Rules:**
- Catalogue position determines import path:
  - vertical="Video", field="Stream", object="H264Delta"
  - → from atomik.Video.Stream import H264Delta
- Object names must be valid identifiers in all target languages

### 3. Three Reference Schemas

Create these example schemas in `sdk/schemas/examples/`:

**Example 1: `terminal-io.json`** (Control Primitive)
- Vertical: "System"
- Field: "Terminal"
- Object: "TerminalIO"
- Use case: Demonstrating basic I/O control with delta-based state
- Delta fields: command_delta (64-bit), response_delta (64-bit)
- Operations: accumulate, reconstruct
- Constraints: Low latency (<1ms), minimal memory

**Example 2: `p2p-delta.json`** (Network Primitive)
- Vertical: "Network"
- Field: "P2P"
- Object: "DeltaExchange"
- Use case: Peer-to-peer delta synchronization
- Delta fields: network_delta (128-bit)
- Operations: accumulate, reconstruct, rollback
- Constraints: Network bandwidth optimization

**Example 3: `matrix-ops.json`** (Compute Primitive)
- Vertical: "Compute"
- Field: "Linear"
- Object: "MatrixOps"
- Use case: Matrix operations with delta-based computation
- Delta fields: matrix_delta (256-bit)
- Operations: accumulate, reconstruct
- Constraints: Computational efficiency

### 4. SDK Schema Guide (Technical Documentation)

Create `docs/SDK_SCHEMA_GUIDE.md` with:

**Section 1: Introduction**
- Purpose of JSON schema-driven SDK generation
- Benefits: Consistency, multi-language support, hardware readiness

**Section 2: Schema Structure**
- Detailed explanation of each section (catalogue, schema, hardware)
- How catalogue maps to API namespace
- How schema defines computational behavior

**Section 3: Field Type Reference**
- delta_stream: Continuous stream of deltas
- bitmask_delta: Bit-level state changes
- parameter_delta: Configuration/parameter updates
- Encoding options: spatiotemporal_4x4x4, raw, rle
- Compression options: xor, rle, none

**Section 4: Operations Reference**
- accumulate: XOR-based delta accumulation (proven single-cycle)
- reconstruct: State reconstruction from accumulated deltas
- rollback: Temporal state rollback via delta reversal

**Section 5: Constraints**
- Memory constraints for edge deployment
- Power constraints for embedded systems
- Latency constraints for real-time applications
- Hardware target specification

**Section 6: Validation**
- How to validate a schema
- Common validation errors and fixes
- Best practices

**Section 7: Examples**
- Walkthrough of each reference schema
- How to create a new schema for your domain

### 5. SDK User Manual (User-Facing Documentation)

Create `docs/user/SDK_USER_MANUAL.md` (initial draft) with:

**Section 1: Getting Started**
- What is ATOMiK SDK
- Who should use it
- Installation instructions (coming in T4A.2+)

**Section 2: Quick Start**
- Using an existing schema
- Generating code in your language
- Basic operations (accumulate, reconstruct)
- 5-minute "Hello, Delta" example

**Section 3: Creating Your First Schema**
- Identify your domain (vertical, field)
- Define your delta fields
- Specify operations and constraints
- Validate your schema

**Section 4: Understanding Namespaces**
- How catalogue position becomes API namespace
- Importing generated code in different languages
- Namespace best practices

**Section 5: Language-Specific Usage**
- Brief overview of each target language
- Links to detailed language guides (coming later)

**Section 6: Next Steps**
- Link to pattern library (Phase 4B)
- Link to hardware integration guide (Phase 4C)
- Community contributions (future)

## Output Files (Must Create)

1. `specs/atomik_schema_v1.json` - JSON Schema Draft 7 format
2. `specs/schema_validation_rules.md` - Validation specification
3. `sdk/schemas/examples/terminal-io.json` - Example 1
4. `sdk/schemas/examples/p2p-delta.json` - Example 2
5. `sdk/schemas/examples/matrix-ops.json` - Example 3
6. `docs/SDK_SCHEMA_GUIDE.md` - Technical reference
7. `docs/user/SDK_USER_MANUAL.md` - User guide (initial)

## Validation Requirements

Before marking this task complete, verify:

1. **Schema Validity:**
   - `specs/atomik_schema_v1.json` is valid JSON Schema Draft 7
   - Can be loaded and parsed without errors

2. **Example Validation:**
   - All three example schemas validate against the specification
   - Each example demonstrates a different use case
   - Examples use different widths, encodings, constraints

3. **Documentation Completeness:**
   - SDK_SCHEMA_GUIDE covers all schema sections
   - SDK_USER_MANUAL provides clear onboarding path
   - Examples are explained with context

4. **Namespace Mapping:**
   - Examples demonstrate hierarchical catalogue structure
   - Clear mapping from JSON to expected import paths
   - Valid identifiers in all target languages

## Post-Task Actions (You Must Do)

1. **Create Directory Structure:**
   ```
   mkdir -p sdk/schemas/examples
   mkdir -p docs/user
   ```

2. **Update Status:**
   Edit `.github/atomik-status.yml`:
   ```yaml
   phase_4:
     status: in_progress
     tasks:
       T4A.1_schema_spec:
         status: complete
         date_completed: [today's date]
   ```

3. **Git Commit:**
   ```bash
   git add specs/atomik_schema_v1.json
   git add specs/schema_validation_rules.md
   git add sdk/schemas/examples/*.json
   git add docs/SDK_SCHEMA_GUIDE.md
   git add docs/user/SDK_USER_MANUAL.md
   git add .github/atomik-status.yml
   git commit -m "[T4A.1] JSON schema specification complete

   Deliverables:
   - JSON schema v1.0 specification (JSON Schema Draft 7)
   - Validation rules documentation
   - 3 reference schemas (terminal-io, p2p-delta, matrix-ops)
   - SDK schema guide (technical reference)
   - SDK user manual (initial draft)
   
   Schema Features:
   - Hierarchical catalogue (vertical/field/object)
   - Delta field definitions with types and encodings
   - Operation specifications (accumulate, reconstruct, rollback)
   - Hardware mapping (optional Verilog generation)
   - Constraint specifications (memory, power, latency)
   
   Namespace Mapping:
   - Catalogue position → API namespace
   - Example: Video/Stream/H264Delta → atomik.Video.Stream.H264Delta
   
   Ready for: T4A.2 (Generator Framework)"
   ```

4. **Report Completion:**
   Output a summary:
   ```
   T4A.1 COMPLETE
   
   Files Created:
   ✓ specs/atomik_schema_v1.json
   ✓ specs/schema_validation_rules.md
   ✓ sdk/schemas/examples/terminal-io.json
   ✓ sdk/schemas/examples/p2p-delta.json
   ✓ sdk/schemas/examples/matrix-ops.json
   ✓ docs/SDK_SCHEMA_GUIDE.md
   ✓ docs/user/SDK_USER_MANUAL.md
   
   Validation:
   ✓ Schema is valid JSON Schema Draft 7
   ✓ All examples validate successfully
   ✓ Documentation complete
   
   Next: HUMAN CHECKPOINT required before T4A.2
   
   Checkpoint Questions:
   1. Does schema support hierarchical namespace mapping?
   2. Are all three example domains covered appropriately?
   3. Is schema extensible for community contributions?
   ```

## Important Notes

**Maintain Simplicity:**
- Schema should be declarative, not imperative
- Avoid complex nested structures
- Keep validation rules straightforward
- Examples should be minimal but representative

**Enable Ecosystem:**
- Catalogue structure supports community contributions
- Namespace mapping is automatic (no manual configuration)
- Schema is language-agnostic (same JSON → multiple targets)
- Hardware mapping is optional (software-first, hardware-ready)

**Align with Strategy:**
- "We keep it simple so you can make it complex"
- Primitives not products (schema defines operations, not applications)
- Platform not product (ecosystem can build on top)

**Reference Phase 3 Success:**
- Single-cycle operations validated on hardware
- 2.7% LUT utilization (massive headroom)
- Schema should enable generation of similarly efficient code

---

Execute this task carefully and completely. Read all context files first. Create all required files. Run all validations. Complete all post-task actions. Report results clearly.

STOP after completing and DO NOT proceed to T4A.2 until human checkpoint is passed.
