# PriceTick
# 
# High-frequency price tick delta processing. Tracks bid/ask price changes and order volume deltas with deep rollback for transaction replay and audit.
# 
# Generated by ATOMiK SDK Generator

from __future__ import annotations

from typing import Optional

class PriceTick:
    """
    High-frequency price tick delta processing. Tracks bid/ask price changes and order volume deltas with deep rollback for transaction replay and audit.

    Delta Fields:
        price_delta: parameter_delta (64-bit)
        volume_delta: delta_stream (64-bit)
        trade_flags: bitmask_delta (64-bit)

    Operations:
        accumulate: Available
        reconstruct: Available
        rollback: Available

    """

    def __init__(self):
        """Initialize delta-state module."""
        self._price_delta_initial: int = 0
        self._price_delta_accumulator: int = 0
        self._volume_delta_initial: int = 0
        self._volume_delta_accumulator: int = 0
        self._trade_flags_initial: int = 0
        self._trade_flags_accumulator: int = 0
        self._price_delta_history: list[int] = []
        self._history_depth = 4096
        self._volume_delta_history: list[int] = []
        self._history_depth = 4096
        self._trade_flags_history: list[int] = []
        self._history_depth = 4096

    def load_price_delta(self, initial_state: int) -> None:
        """
        Load initial state for price_delta.

        Args:
            initial_state: Initial 64-bit state value
        """
        self._price_delta_initial = initial_state & 0xffffffffffffffff

    def accumulate_price_delta(self, delta: int) -> int:
        """
        Accumulate delta for price_delta via XOR.

        Args:
            delta: 64-bit delta value

        Returns:
            Updated accumulator value
        """
        # Save to history
        self._price_delta_history.append(delta)
        if len(self._price_delta_history) > self._history_depth:
                self._price_delta_history.pop(0)

        self._price_delta_accumulator ^= (delta & 0xffffffffffffffff)
        return self._price_delta_accumulator

    def reconstruct_price_delta(self) -> int:
        """
        Reconstruct current state for price_delta.

        Returns:
            Current state value
        """
        return (self._price_delta_initial ^ self._price_delta_accumulator) & 0xffffffffffffffff

    def load_volume_delta(self, initial_state: int) -> None:
        """
        Load initial state for volume_delta.

        Args:
            initial_state: Initial 64-bit state value
        """
        self._volume_delta_initial = initial_state & 0xffffffffffffffff

    def accumulate_volume_delta(self, delta: int) -> int:
        """
        Accumulate delta for volume_delta via XOR.

        Args:
            delta: 64-bit delta value

        Returns:
            Updated accumulator value
        """
        # Save to history
        self._volume_delta_history.append(delta)
        if len(self._volume_delta_history) > self._history_depth:
                self._volume_delta_history.pop(0)

        self._volume_delta_accumulator ^= (delta & 0xffffffffffffffff)
        return self._volume_delta_accumulator

    def reconstruct_volume_delta(self) -> int:
        """
        Reconstruct current state for volume_delta.

        Returns:
            Current state value
        """
        return (self._volume_delta_initial ^ self._volume_delta_accumulator) & 0xffffffffffffffff

    def load_trade_flags(self, initial_state: int) -> None:
        """
        Load initial state for trade_flags.

        Args:
            initial_state: Initial 64-bit state value
        """
        self._trade_flags_initial = initial_state & 0xffffffffffffffff

    def accumulate_trade_flags(self, delta: int) -> int:
        """
        Accumulate delta for trade_flags via XOR.

        Args:
            delta: 64-bit delta value

        Returns:
            Updated accumulator value
        """
        # Save to history
        self._trade_flags_history.append(delta)
        if len(self._trade_flags_history) > self._history_depth:
                self._trade_flags_history.pop(0)

        self._trade_flags_accumulator ^= (delta & 0xffffffffffffffff)
        return self._trade_flags_accumulator

    def reconstruct_trade_flags(self) -> int:
        """
        Reconstruct current state for trade_flags.

        Returns:
            Current state value
        """
        return (self._trade_flags_initial ^ self._trade_flags_accumulator) & 0xffffffffffffffff

    def rollback(self, steps: int = 1) -> bool:
        """
        Rollback state by reversing recent deltas.

        Args:
            steps: Number of deltas to rollback

        Returns:
            True if rollback successful
        """
        if steps > len(self._price_delta_history):
            return False

        for _ in range(steps):
            delta = self._price_delta_history.pop()
            self._price_delta_accumulator ^= delta
            delta = self._volume_delta_history.pop()
            self._volume_delta_accumulator ^= delta
            delta = self._trade_flags_history.pop()
            self._trade_flags_accumulator ^= delta

        return True

    def is_accumulator_zero(self, field_name: Optional[str] = None) -> bool:
        """
        Check if accumulator is zero (no pending deltas).

        Args:
            field_name: Optional field name to check (None = check all)

        Returns:
            True if accumulator(s) are zero
        """
        if field_name:
            return getattr(self, f"_{field_name}_accumulator") == 0

        return self._price_delta_accumulator == 0 and self._volume_delta_accumulator == 0 and self._trade_flags_accumulator == 0