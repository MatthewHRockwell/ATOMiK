"""
Bitstream Generator Module - Low-level API for Verilog synthesis.

This module provides the BitstreamGenerator class for generating
synthesizable Verilog code from genome configurations.
"""

from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional, Union
from .genome_compiler import Genome, GenomeInstruction


class BitstreamGenerator:
    """
    Generator for producing synthesizable Verilog from genome files.
    
    The BitstreamGenerator takes compiled genome configurations and
    produces Verilog RTL code targeting specific FPGA platforms.
    
    Example:
        >>> gen = BitstreamGenerator()
        >>> gen.load_genome("config.gnm")
        >>> verilog = gen.synthesize_verilog()
        >>> with open("output.v", "w") as f:
        ...     f.write(verilog)
    """
    
    def __init__(self, target: str = "gowin_gw1nr9"):
        """
        Initialize the BitstreamGenerator.
        
        Args:
            target: Target FPGA platform identifier.
        """
        self.target = target
        self.genome: Optional[Genome] = None
        self.module_name = "atomik_core"
    
    def load_genome(self, path: Union[str, Path]) -> None:
        """
        Load a genome file for synthesis.
        
        Args:
            path: Path to the .gnm genome file.
        """
        self.genome = Genome.load(path)
    
    def set_genome(self, genome: Genome) -> None:
        """
        Set a genome object directly.
        
        Args:
            genome: Compiled Genome object.
        """
        self.genome = genome
    
    def synthesize_verilog(self, module_name: Optional[str] = None) -> str:
        """
        Generate Verilog RTL code from the loaded genome.
        
        Args:
            module_name: Optional name for the generated module.
        
        Returns:
            String containing synthesizable Verilog code.
        
        Raises:
            ValueError: If no genome is loaded.
        """
        if self.genome is None:
            raise ValueError("No genome loaded")
        
        if module_name:
            self.module_name = module_name
        
        lines = []
        
        # Module header
        lines.append(self._generate_header())
        lines.append(self._generate_ports())
        lines.append("")
        
        # Internal signals
        lines.append(self._generate_signals())
        lines.append("")
        
        # Instruction ROM
        lines.append(self._generate_instruction_rom())
        lines.append("")
        
        # State machine
        lines.append(self._generate_state_machine())
        lines.append("")
        
        # Module footer
        lines.append("endmodule")
        
        return "\n".join(lines)
    
    def _generate_header(self) -> str:
        """Generate module header with documentation."""
        return f"""// ATOMiK Core - Auto-generated from genome "{self.genome.name}"
// Version: {self.genome.version}
// Target: {self.target}
// Generated by BitstreamGenerator

`timescale 1ns / 1ps

module {self.module_name} ("""
    
    def _generate_ports(self) -> str:
        """Generate port declarations."""
        return """    input  wire        clk,
    input  wire        rst_n,
    input  wire        enable,
    input  wire [63:0] data_in,
    input  wire        data_valid,
    output reg  [63:0] data_out,
    output reg         data_ready,
    output reg  [3:0]  motif_id,
    output reg         event_flag
);"""
    
    def _generate_signals(self) -> str:
        """Generate internal signal declarations."""
        inst_count = len(self.genome.instructions)
        addr_width = max(1, (inst_count - 1).bit_length())
        
        return f"""    // Internal registers
    reg [63:0] accumulator;
    reg [63:0] prev_data;
    reg [{addr_width-1}:0] pc;
    reg [2:0] state;
    
    // State definitions
    localparam IDLE    = 3'b000;
    localparam FETCH   = 3'b001;
    localparam DECODE  = 3'b010;
    localparam EXECUTE = 3'b011;
    localparam OUTPUT  = 3'b100;
    localparam HALT    = 3'b101;
    
    // Instruction fields
    wire [7:0] opcode;
    wire [7:0] operand_a;
    wire [7:0] operand_b;
    wire [7:0] codon_seq;
    reg [31:0] instruction;"""
    
    def _generate_instruction_rom(self) -> str:
        """Generate instruction ROM from genome."""
        lines = ["    // Instruction ROM"]
        lines.append(f"    reg [31:0] rom [{len(self.genome.instructions)-1}:0];")
        lines.append("")
        lines.append("    initial begin")
        
        for i, inst in enumerate(self.genome.instructions):
            packed = (
                (inst.opcode & 0xFF) |
                ((inst.operand_a & 0xFF) << 8) |
                ((inst.operand_b & 0xFF) << 16) |
                ((self._encode_codons(inst.codon_sequence) & 0xFF) << 24)
            )
            lines.append(f"        rom[{i}] = 32'h{packed:08X};  // {self._opcode_name(inst.opcode)}")
        
        lines.append("    end")
        lines.append("")
        lines.append("    assign opcode    = instruction[7:0];")
        lines.append("    assign operand_a = instruction[15:8];")
        lines.append("    assign operand_b = instruction[23:16];")
        lines.append("    assign codon_seq = instruction[31:24];")
        
        return "\n".join(lines)
    
    def _generate_state_machine(self) -> str:
        """Generate the main state machine."""
        return """    // Main state machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            pc <= 0;
            accumulator <= 64'b0;
            prev_data <= 64'b0;
            data_out <= 64'b0;
            data_ready <= 1'b0;
            motif_id <= 4'b0;
            event_flag <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    data_ready <= 1'b0;
                    event_flag <= 1'b0;
                    if (enable && data_valid) begin
                        prev_data <= accumulator;
                        accumulator <= data_in;
                        state <= FETCH;
                    end
                end
                
                FETCH: begin
                    instruction <= rom[pc];
                    state <= DECODE;
                end
                
                DECODE: begin
                    state <= EXECUTE;
                end
                
                EXECUTE: begin
                    case (opcode)
                        8'h00: begin // NOP
                            pc <= pc + 1;
                            state <= FETCH;
                        end
                        8'h01: begin // XOR
                            accumulator <= accumulator ^ prev_data;
                            pc <= pc + 1;
                            state <= FETCH;
                        end
                        8'h0D: begin // EMIT
                            data_out <= accumulator;
                            data_ready <= 1'b1;
                            pc <= pc + 1;
                            state <= OUTPUT;
                        end
                        8'h0E: begin // CLASSIFY
                            motif_id <= classify_motif(accumulator);
                            event_flag <= (accumulator != 64'b0);
                            pc <= pc + 1;
                            state <= FETCH;
                        end
                        8'h0F: begin // HALT
                            state <= HALT;
                        end
                        default: begin
                            pc <= pc + 1;
                            state <= FETCH;
                        end
                    endcase
                end
                
                OUTPUT: begin
                    data_ready <= 1'b0;
                    state <= IDLE;
                    pc <= 0;
                end
                
                HALT: begin
                    // Wait for reset
                end
            endcase
        end
    end
    
    // Motif classification function
    function [3:0] classify_motif;
        input [63:0] delta;
        reg [6:0] bit_count;
        begin
            bit_count = $countones(delta);
            if (delta == 64'b0)
                classify_motif = 4'h0;  // STATIC
            else if (bit_count < 8)
                classify_motif = 4'hE;  // NOISE
            else if ((delta >> 32) > (delta & 32'hFFFFFFFF))
                classify_motif = 4'h2;  // VERTICAL
            else
                classify_motif = 4'h1;  // HORIZONTAL
        end
    endfunction"""
    
    def _encode_codons(self, sequence: str) -> int:
        """Encode codon sequence to byte."""
        codon_map = {"A": 0, "G": 1, "T": 2, "C": 3}
        result = 0
        for i, c in enumerate(sequence[:4]):
            if c in codon_map:
                result |= (codon_map[c] << (i * 2))
        return result
    
    def _opcode_name(self, opcode: int) -> str:
        """Get opcode name for comments."""
        names = {
            0x00: "NOP", 0x01: "XOR", 0x02: "AND", 0x03: "OR",
            0x04: "NOT", 0x05: "SHIFT_L", 0x06: "SHIFT_R",
            0x07: "ROTATE_L", 0x08: "ROTATE_R", 0x09: "COMPARE",
            0x0A: "BRANCH", 0x0B: "LOAD", 0x0C: "STORE",
            0x0D: "EMIT", 0x0E: "CLASSIFY", 0x0F: "HALT"
        }
        return names.get(opcode, f"UNKNOWN({opcode:#04x})")
    
    def generate_testbench(self) -> str:
        """
        Generate a Verilog testbench for the synthesized module.
        
        Returns:
            String containing testbench Verilog code.
        """
        return f"""// Testbench for {self.module_name}
// Auto-generated by BitstreamGenerator

`timescale 1ns / 1ps

module tb_{self.module_name};

    // Clock and reset
    reg clk;
    reg rst_n;
    
    // DUT signals
    reg enable;
    reg [63:0] data_in;
    reg data_valid;
    wire [63:0] data_out;
    wire data_ready;
    wire [3:0] motif_id;
    wire event_flag;
    
    // Instantiate DUT
    {self.module_name} dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .data_in(data_in),
        .data_valid(data_valid),
        .data_out(data_out),
        .data_ready(data_ready),
        .motif_id(motif_id),
        .event_flag(event_flag)
    );
    
    // Clock generation
    initial clk = 0;
    always #18.5 clk = ~clk;  // 27 MHz
    
    // Test sequence
    initial begin
        $dumpfile("tb_{self.module_name}.vcd");
        $dumpvars(0, tb_{self.module_name});
        
        // Initialize
        rst_n = 0;
        enable = 0;
        data_in = 64'b0;
        data_valid = 0;
        
        #100 rst_n = 1;
        #100 enable = 1;
        
        // Test case 1: First frame
        data_in = 64'hFF00FF00FF00FF00;
        data_valid = 1;
        #37 data_valid = 0;
        
        // Wait for processing
        wait(data_ready);
        $display("Output 1: %h, Motif: %d", data_out, motif_id);
        
        #100;
        
        // Test case 2: Second frame (creates delta)
        data_in = 64'h00FF00FF00FF00FF;
        data_valid = 1;
        #37 data_valid = 0;
        
        wait(data_ready);
        $display("Output 2: %h, Motif: %d, Event: %b", data_out, motif_id, event_flag);
        
        #100;
        
        $display("PASS: Testbench completed");
        $finish;
    end
    
    // Timeout
    initial begin
        #10000;
        $display("FAIL: Testbench timeout");
        $finish;
    end

endmodule
"""
